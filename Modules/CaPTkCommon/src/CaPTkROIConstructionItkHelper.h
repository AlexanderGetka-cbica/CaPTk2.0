#ifndef CaPTkROIConstructionItkHelper_h
#define CaPTkROIConstructionItkHelper_h

// The following header file is generated by CMake and thus it's located in
// the build directory. It provides an export macro for classes and functions
// that you want to be part of the public interface of your module.
#include <MitkCaPTkCommonExports.h>

#include "CaPTkROIConstructionItkHelperBase.h"
#include "CaPTkROIConstructionImplementation.h"

#include <mitkImageCast.h>
#include <itkExtractImageFilter.h>
#include <mitkImageAccessByItk.h>
#include <mitkITKImageImport.h>

#include "itkImageRegionIteratorWithIndex.h"

#include <string>

namespace captk
{
template <typename TPixel, unsigned int VImageDimension>
class MITKCAPTKCOMMON_EXPORT ROIConstructionItkHelper :
                      public ROIConstructionItkHelperBase
{
public:

    using TImageType = itk::Image<TPixel, VImageDimension>;
    using TImageTypePointer = typename TImageType::Pointer;

    ROIConstructionItkHelper(TImageTypePointer mask) 
    {
        m_Mask = mask;
    }

    ~ROIConstructionItkHelper()
    {

    }

    void SetValuesAndNames(
        std::vector<int> values, 
        std::vector<std::string> names) override
    {
        m_Values = values;
        m_Names = names;
    }

    size_t GetPropertiesSize() override
    {
        return m_Properties.size();
    }

    /** \brief Find all the different lattice points
     * 
     * See CaPTkROIConstructionImplementation for what the parameters are
     */
    void Update(
        bool  lattice,
        float window,
        bool  fluxNeumannCondition,
        bool  patchConstructionROI,
        bool  patchConstructionNone,
        float step) override
    {
        if (!lattice)
        {
            window = step = 0;
        }

        captk::ROIConstructionImplementation< TImageType > roiConstructor;
        roiConstructor.SetInputMask(m_Mask);
        roiConstructor.SetSelectedROIsAndLabels(m_Values, m_Names);
        roiConstructor.SetLatticeGridStep(step);
        roiConstructor.SetLatticeWindowSize(window);
        roiConstructor.SetBoundaryCondition(fluxNeumannCondition);
        roiConstructor.SetPatchConstructionConditionROI(patchConstructionROI);
        roiConstructor.SetPatchConstructionConditionNone(patchConstructionNone);
        roiConstructor.Update();

        m_Properties = roiConstructor.GetOutput();
    }

    std::string GetPropertyLabel(size_t patchPos) override
    {
        return this->m_Properties[patchPos].label;
    }

    int GetPropertyValue(size_t patchPos) override
    {
        return this->m_Properties[patchPos].value;
    }

    void PopulateMaskAtPatch (
        size_t patchPos, 
        mitk::LabelSetImage::Pointer miniMask) override
    {
        // Convert mitk::LabelSetImage::Pointer to TImageType
        using ImageToItkType = mitk::ImageToItk<TImageType>;
        typename ImageToItkType::Pointer imagetoitk = ImageToItkType::New();
        imagetoitk->SetInput(miniMask);
        imagetoitk->Update();
        TImageTypePointer miniMaskItk = imagetoitk->GetOutput();

        using TIteratorType = itk::ImageRegionIteratorWithIndex<TImageType>;
        TIteratorType iter_mm(
            miniMaskItk, miniMaskItk->GetBufferedRegion()
        );

        // Patch: this->m_Properties[patchPos]
        // Patch is generally a collection of points
        for (auto& index : this->m_Properties[patchPos].nonZeroIndeces)
        {
            iter_mm.SetIndex(index);
            iter_mm.Set(1);
        }
    }

private:

    std::vector<
        typename captk::ROIConstructionImplementation<TImageType>::ROIProperties
    > m_Properties;

    TImageTypePointer m_Mask;
    std::vector<int> m_Values;
    std::vector<std::string> m_Names;
};
}

#endif // ! CaPTkROIConstructionItkHelper_h