#ifndef CaPTkROIConstructionHelperItk_h
#define CaPTkROIConstructionHelperItk_h

// The following header file is generated by CMake and thus it's located in
// the build directory. It provides an export macro for classes and functions
// that you want to be part of the public interface of your module.
#include <MitkCaPTkCommonExports.h>

#include "CaPTkROIConstructionHelperBase.h"
#include "CaPTkROIConstructionImplementation.h"

#include <mitkImageCast.h>
#include <itkExtractImageFilter.h>
#include <mitkImageAccessByItk.h>
#include <mitkITKImageImport.h>

#include "itkImageRegionIteratorWithIndex.h"

#include <string>

namespace captk
{
template <typename TPixel, unsigned int VImageDimension>
class MITKCAPTKCOMMON_EXPORT ROIConstructionHelperItk :
                      public ROIConstructionHelperBase
{
public:

    using TImageType = itk::Image<TPixel, VImageDimension>;
    using TImageTypePointer = typename TImageType::Pointer;

    ROIConstructionHelperItk(TImageTypePointer mask) 
    {
        m_Mask = mask;
    }

    ~ROIConstructionHelperItk()
    {

    }

    void SetValuesAndNames(
        std::vector<int> values, 
        std::vector<std::string> names) override
    {
        m_Values = values;
        m_Names = names;
    }

    /** \brief Find all the different lattice points
     * 
     * See CaPTkROIConstructionImplementation for what the parameters are
     */
    void Update(
        float radius,
        float step//, 
        // bool  fluxNeumannCondition,
        // bool  patchConstructionROI,
        // bool  patchConstructionNone
        ) override
    {
        m_CurrentIndex = 0;

        captk::ROIConstructionImplementation< TImageType > roiConstructorItk;

        roiConstructorItk.SetInputMask(m_Mask);
        roiConstructorItk.SetSelectedROIsAndLabels(m_Values, m_Names);
        roiConstructorItk.SetLatticeGridStep(step);
        roiConstructorItk.SetLatticeWindowSize(2.0 * radius);
        // roiConstructorItk.SetBoundaryCondition(fluxNeumannCondition);
        // roiConstructorItk.SetPatchConstructionConditionROI(patchConstructionROI);
        // roiConstructorItk.SetPatchConstructionConditionNone(patchConstructionNone);
        
        roiConstructorItk.Update();

        // Show info
        std::cout << "\nNumber of valid lattice points: " 
                  << roiConstructorItk.GetNumberOfValidLatticePoints()
                  << std::endl;

        std::cout << "Lattice radius: " 
                  << roiConstructorItk.GetLatticeRadius()
                  << std::endl;

        m_Properties = roiConstructorItk.GetOutput();
    }

    float PopulateMask(mitk::LabelSetImage::Pointer miniMask) override
    {
        // Add label and label name
        mitk::Label::Pointer label = mitk::Label::New();
        label->SetName(m_Properties[m_CurrentIndex].label);
        label->SetValue(m_Properties[m_CurrentIndex].value);
        miniMask->GetActiveLabelSet()->AddLabel(label);
        //miniMask->SetActiveLabel(label->GetValue());

        // Convert mitk::LabelSetImage::Pointer to TImageType
        using ImageToItkType = mitk::ImageToItk<TImageType>;
        typename ImageToItkType::Pointer imagetoitk = ImageToItkType::New();
        imagetoitk->SetInput(miniMask);
        imagetoitk->Update();
        TImageTypePointer miniMaskItk = imagetoitk->GetOutput();

        using TIteratorType = itk::ImageRegionIteratorWithIndex<TImageType>;
        TIteratorType iter_mm(
            miniMaskItk, miniMaskItk->GetBufferedRegion()
        );

        // Patch: this->m_Properties[m_CurrentIndex]
        // Patch is generally a collection of points
        auto currentValue = this->m_Properties[m_CurrentIndex].value;
        for (auto& index : this->m_Properties[m_CurrentIndex].nonZeroIndeces)
        {
            iter_mm.SetIndex(index);
            iter_mm.Set(currentValue);
        }

        return this->m_Properties[m_CurrentIndex].weight;
    }

    virtual void GoToBegin()
    {
        m_CurrentIndex = 0;
    }

    virtual bool IsAtEnd()
    {
        return (m_CurrentIndex == m_Properties.size() - 1);
    }

    void OnIncrement() override
    {
        m_CurrentIndex++;
    }

private:

    std::vector<
        typename captk::ROIConstructionImplementation<TImageType>::ROIProperties
    > m_Properties;

    TImageTypePointer m_Mask;
    std::vector<int> m_Values;
    std::vector<std::string> m_Names;

    size_t m_CurrentIndex = 0;
};
}

#endif // ! CaPTkROIConstructionHelperItk_h