#ifndef CaPTkROIConstructionCreateLatticePoints_h
#define CaPTkROIConstructionCreateLatticePoints_h

// The following header file is generated by CMake and thus it's located in
// the build directory. It provides an export macro for classes and functions
// that you want to be part of the public interface of your module.
#include <MitkCaPTkCommonExports.h>

#include <itkImage.h>
#include <itkImageRegionIteratorWithIndex.h>

#include <vector>

namespace captk
{

/** \brief Get a list of all lattice indices 
 * \param mask the input mask
 * \param stepInMillimeters desired distance between the points
 * \param pointsOnlyOnMask will return points only at non-zero pixels/voxels of the ROI
 * \return std::vector of all the indeces
*/
template <class TPixel, unsigned int VImageDimension>
MITKCAPTKCOMMON_EXPORT std::vector<typename itk::Image<TPixel, VImageDimension>::IndexType>
ROIConstructionCreateLatticePoints(
    typename itk::Image<TPixel, VImageDimension>::Pointer mask,
    const double stepInMillimeters,
    bool pointsOnlyOnMask=true)
{
    using ImageType    = itk::Image<TPixel, VImageDimension>;
    using IndexType    = typename ImageType::IndexType;
    using ImagePointer = typename ImageType::Pointer;
    using SpacingType  = typename ImageType::SpacingType;
    using SizeType     = typename ImageType::SizeType;

    // NOTE: We may need to make the "stepInMillimeters" have the same type as ImageType::SpacingValueType
    // To do this, template for <class ImageType> instead of TPixel & VImageDimension

    // NOTE: this function assumes spacing in mm

    const SpacingType &spacing_between_pixels = mask->GetSpacing();

    // calculate the required pixel-wise spacing
    SpacingType px_per_step;
    for (unsigned int current_dim = 0; current_dim < VImageDimension; current_dim++)
    {
        if (current_dim < 3)
        { // spatial dimensions
            if (stepInMillimeters >= spacing_between_pixels[current_dim])
            {
                px_per_step[current_dim] = stepInMillimeters / spacing_between_pixels[current_dim]; // calculate spatial px/step ratio
            }
            else
            { // the resolution along this dimension is too low -- every index along this dimension is selected
                px_per_step[current_dim] = 1;
            }
        }
        else
        { // time dimension, or some other dimension, for which physical spacing has no meaning
            px_per_step[current_dim] = 1;
        }
    }

    std::vector<IndexType> result_vector;

    SizeType mask_size = mask->GetLargestPossibleRegion().GetSize(); // Size of image in each dimension is used to calculate bounding
    std::vector<std::vector<int>> all_valid_index_sets;              // initialize storage for spaced index lists for each dimension

    for (unsigned int current_dim = 0; current_dim < VImageDimension; current_dim++)
    {
        std::vector<int> valid_indices_along_current_dimension; // initialize vector to store spaced indices along one dimension

        for (double cumulative_index_by_px = 0.0; cumulative_index_by_px < mask_size[current_dim]; cumulative_index_by_px += px_per_step[current_dim])
        {
            valid_indices_along_current_dimension.push_back(int(cumulative_index_by_px));
        }
        all_valid_index_sets.push_back(valid_indices_along_current_dimension);
    }

    int total_points = 1; // initialize for multiplicative counting
    for (unsigned int current_dim = 0; current_dim < VImageDimension; current_dim++)
    {
        total_points *= all_valid_index_sets[current_dim].size();
    }

    // Iterator to check it the proposed point is part of the ROI of the mask
    itk::ImageRegionIteratorWithIndex<ImageType> iter(mask, mask->GetRequestedRegion());

    for (int i = 0; i < total_points; i++)
    {
        IndexType this_point;
        /* The below code works by using the numerical indices as divisors. if X axis has 5 valid spaced positions,
         * and Y has 3, and Z has 6, the total number of valid point indices is 5*3*6 = 90 total valid, unique points (which we calculated above).
         * "Selecting" any valid position along X means there are 90/5 = 18 = 3*6 valid points with that specific X-position.
         * Using modulus "selects" a position in the current range based on the unique point's corresponding number. 90%5 = 0, 89%5 = 1, 88%5 = 3...
         *
         * So for each point, we start with i, or its place in the set of all valid points.
         * "factor" tracks our current factor as we go over each dimension (getting divided as we "select" a position for each dimension).
         * For each dimension, we take "n_index" to be the remainder (modulus) of the division of our current factor
         * by the amount of valid positions in the dimension we are currently considering.
         * This value "n_index" acts as our index into the current dimension to find what that dimension's n-th valid spaced position is.
         * The newly-divided "factor" is then used in the same way to find the remainder/index for the next dimension, and so on.
        */
        auto factor = i;
        for (unsigned int dim = 0; dim < all_valid_index_sets.size(); dim++)
        {
            std::vector<int> const positions = all_valid_index_sets[dim];
            auto n_index = factor % positions.size();
            factor /= positions.size();
            this_point[dim] = positions[n_index];
        }

        // If it is part of the ROI, add it to the result (or if we include everything anyway)
        iter.SetIndex(this_point);
        if ((!pointsOnlyOnMask) || (iter.Get() > 0))
        {
            result_vector.push_back(this_point);
        }
    }

    return result_vector;
}

} // ! captk

#endif // ! CaPTkROIConstructionCreateLatticePoints_h
