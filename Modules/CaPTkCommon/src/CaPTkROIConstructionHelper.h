#ifndef CaPTkROIConstructionHelperBase_h
#define CaPTkROIConstructionHelperBase_h

// The following header file is generated by CMake and thus it's located in
// the build directory. It provides an export macro for classes and functions
// that you want to be part of the public interface of your module.
#include <MitkCaPTkCommonExports.h>

#include <mitkLabelSetImage.h>
#include <mitkLabelSet.h>

#include "itkNeighborhoodIterator.h"

#include <string>
#include <vector>

#include "CaPTkROIConstructionHelperBase.h"
#include "CaPTkROIConstructionCreateLatticePoints.h"

namespace captk
{
/** \class ROIConstructionHelper
 * \brief Templated class to create the lattice ROIs
 */
template <typename TPixel, unsigned int VImageDimension>
class MITKCAPTKCOMMON_EXPORT ROIConstructionHelper : public ROIConstructionHelperBase
{
public:

    using TImageType        = itk::Image<TPixel, VImageDimension>;
    using TImageTypePointer = typename TImageType::Pointer;
    using TIndexType        = typename TImageType::IndexType;
    using TSizeType         = typename TImageType::SizeType;

    ROIConstructionHelper(TImageTypePointer mask)
    {
        m_Mask = mask;
    }

    ~ROIConstructionHelperBase()
    {

    }

    void Update(
        float radius,
        float step) override
    {
        m_Radius = radius;
        m_Indeces = captk::ROIConstructionCreateLatticePoints(m_Mask, step);
        m_CurrentIndex = 0;
    }

    bool HasNext() override
    {
        return ( m_CurrentIndex + 1 < m_Indeces.size() );
    }

    // void SetValuesAndNames(mitk::LabelSet::Pointer labelSet) override
    // {
    //     mitk::LabelSet::LabelContainerConstIteratorType it;
    //     for (it = labelSet->IteratorConstBegin();
    //          it != labelSet->IteratorConstEnd();
    //          ++it)
    //     {
    //         if (it->second->GetValue() != 0)
    //         {
    //             // std::cout << "Found label set name: "
    //             //           << it->second->GetName() << "\n";
    //             m_Values.push_back(it->second->GetValue());
    //             m_Names.push_back(it->second->GetName());
    //         }
    //     }
    // }

    void PopulateMask(mitk::LabelSetImage::Pointer rMask) override
    {
        // Convert mitk::LabelSetImage::Pointer to TImageType
        using ImageToItkType = mitk::ImageToItk<TImageType>;
        typename ImageToItkType::Pointer imagetoitk = ImageToItkType::New();
        imagetoitk->SetInput(rMask);
        imagetoitk->Update();
        TImageTypePointer rMaskItk = imagetoitk->GetOutput();

        // Radius for the neighborhood iterator
        typename ImageType::SizeType radiusSizeType;
        for (int i = 0; i < ImageType::ImageDimension; i++)
        {
            if (i + 1 > 3) { radiusSizeType[i] = 1; }
            else           { radiusSizeType[i] = m_Radius; } // TODO: m_Radius IN MILLIMETERS
        }

        // Iterate through the neighborhood until you find the current lattice index
        itk::NeighborhoodIterator<ImageType> iter_nm(radiusSizeType, mask,
                                                     mask->GetRequestedRegion());
        for (iter_nm.GoToBegin(); !iter_nm.IsAtEnd(); ++iter_nm)
        {
            // Check if the index is the same as the one we want
            if (iter_nm.GetIndex() == ind1)
            {
                // Iterate through the neighborhood
                for (unsigned int i = 0; i < iter_nm.Size(); ++i)
                {
                    iter_nm.SetPixel(i, 1);
                }
            }
        }
    }

protected:
    void OnIncrement() override
    {

    }

private:
    // std::vector<int>         m_Values;
    // std::vector<std::string> m_Names;
    size_t                   m_CurrentIndex;
    TImageTypePointer        m_Mask;
    std::vector<TIndexType>  m_Indeces;
    float                    m_Radius;

};
} // namespace captk

#endif // ! CaPTkROIConstructionHelperBase_h